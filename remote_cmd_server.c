/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "remote_cmd.h"
#include <stdlib.h> // malloc, realloc
#include <stdio.h> // sprintf
#include <string.h> // strlen
#include <unistd.h> // dup2, read
#include <fcntl.h> // fcntl
#include <sys/wait.h> // waitpid
#include <math.h>

ServerOutput *
execute_cmd_1_svc(ClientInput* argp, struct svc_req* rqstp) {
  static ServerOutput  result;
  result.stdout_ = (char*) malloc(sizeof(char) * 1);
  result.stderr_ = (char*) malloc(sizeof(char) * 1);
  //printf("Parts: %d / %d\n", argp->part_ , -argp->parts_);
	if (argp->part_ == -1) {
		printf("Create input files\n");
		result.part_ = -1;
		FILE* comm = fopen("/tmp/command", "w");
		fclose(comm);
		FILE* flags = fopen("/tmp/flags", "w");
		fclose(flags);
		FILE* in = fopen("/tmp/stdin", "w");
		fclose(in);
	}

	if (argp->part_ <= -2) {
    printf("Fragmented parts: %d / %d\n", -argp->part_ - 2, -argp->parts_);
		result.part_ = argp->part_;
		FILE* comm = fopen("/tmp/command", "a+");
		fprintf(comm, "%s", argp->program_name_);
		printf("Append command: %lu '%s'\n", strlen(argp->program_name_), argp->program_name_);
		fclose(comm);
		FILE* flags = fopen("/tmp/flags", "a+");
		fprintf(flags, "%s", argp->flags_);
		printf("Append flgs:    %lu '%s'\n", strlen(argp->flags_), argp->flags_);
		fclose(flags);
		FILE* in = fopen("/tmp/stdin", "a+");
		fprintf(in, "%s", argp->stdin_);
		printf("Append stdin:   %lu '%s'\n", strlen(argp->stdin_), argp->stdin_);
		fclose(in);
	}

	if (argp->part_ == 0) {
	      printf("EXECUTING!\n");
	    FILE* comm = fopen("/tmp/command", "r");
	    fseek(comm, 0L, SEEK_END);
      size_t comm_size = ftell(comm);
      fseek(comm, 0, SEEK_SET);
      //printf("comm_size %lu\n", comm_size);
      char* command = (char*) malloc(comm_size * sizeof(char));
      fscanf(comm, "%s", command);
      fclose(comm);
      
      FILE* flags = fopen("/tmp/flags", "r");
	    fseek(flags, 0L, SEEK_END);
      size_t flags_size = ftell(flags);
      fseek(flags, 0, SEEK_SET);
      //printf("flags size %lu\n", flags_size);
      char* flags_all;
      if (flags_size > 0) {
      	flags_all = (char*) malloc(flags_size * sizeof(char));
        fscanf(flags, "%s", flags_all);
      } else {
        flags_all = (char*) malloc(2 * sizeof(char));
        flags_all[0] = '\0';
      }
      fclose(flags);
      
      char* full_command = 
          (char*) malloc((comm_size + 1 + flags_size + 1) * sizeof(char));
  sprintf(full_command, "%s %s", command, flags_all);

//printf("Command: '%s'\n", full_command);
  enum thread {
    EXECUTABLE = 1,
    INPUT = 0
  };
  printf("command: '%s'\n", command);
  printf("flags: '%s'\n", flags_all);
  printf("all: '%s'\n", full_command);
  int fd_stdin[2];
  int fd_stdout[2];
  int fd_stderr[2];
  pipe(fd_stdin);
  pipe(fd_stdout);
  pipe(fd_stderr);
  int exec_pid = fork();
  if (exec_pid >= 0) {
    if (exec_pid == 0) {
      // Redirect stdin, out, err. - Do not show on server size.
      // Make it possible to capture from stdin thread.
      dup2(fd_stdin[INPUT], STDIN_FILENO);
      dup2(fd_stdout[EXECUTABLE], STDOUT_FILENO);
      dup2(fd_stderr[EXECUTABLE], STDERR_FILENO);

      // Close all after dup2
      for (size_t i = 0; i < 2; ++i) {
        close(fd_stdin[i]);
        close(fd_stdout[i]);
        close(fd_stderr[i]);
      }
      //printf("Executing NOW!\n");
      exit(system(full_command));
    } else {
      // Do not need - dup2
      close(fd_stdin[INPUT]);
      close(fd_stdout[EXECUTABLE]);
      close(fd_stderr[EXECUTABLE]);

      FILE* in_file = fopen("/tmp/stdin", "r");
	    fseek(in_file, 0L, SEEK_END);
      size_t in_size = ftell(in_file);
      const size_t stream_len = 8 * 1024;
      char* in_part = (char*) malloc(stream_len * sizeof(char) + 1);
      //printf("input size: %lu\n", in_size);
      fseek(in_file, 0, SEEK_SET);
      for (size_t i = 0; i < in_size; i += stream_len) {
        printf ("stdin\n");
        fseek(in_file, i * stream_len, SEEK_SET);
        size_t len = fread(in_part, sizeof(char), stream_len, in_file);
        in_part[len] = '\0';
        write(fd_stdin[EXECUTABLE], in_part, len);
      }
      close(fd_stdin[EXECUTABLE]);

      // Wait for thread to end.
      int status;
      printf("Waiting NOW!\n");
      waitpid(exec_pid, &status, 0);
      result.status_ = status;
			FILE* status_file = fopen("/tmp/status", "w");
			fprintf(status_file, "%d", status);
			fclose(status_file);
      // Unblock stdout and stderr
      fcntl(fd_stdout[INPUT], F_SETFL, O_NONBLOCK);
      fcntl(fd_stderr[INPUT], F_SETFL, O_NONBLOCK);

      // Read full stdout with 8kb chunks.
      static const size_t read_chunk = 8 * 1024;
      result.stdout_ = (char*) malloc(sizeof(char) * read_chunk + 1);
      size_t read_bytes = 0;
      FILE* stdout_file = fopen("/tmp/stdout", "w");
      while ((read_bytes = read(fd_stdout[INPUT], result.stdout_, read_chunk)) > 0) {
        printf("Saving stdout: %lu\n", read_bytes);
        result.stdout_[read_bytes] = '\0';
      	fprintf(stdout_file, "%s", result.stdout_);
      }
      fclose(stdout_file);
      // Read full stderr with 8kb chunks.
      result.stderr_ = (char*) malloc(sizeof(char) * read_chunk);


      FILE* stderr_file = fopen("/tmp/stderr", "w");
      while ((read_bytes = read(fd_stderr[INPUT], result.stderr_, read_chunk)) > 0) {
        result.stderr_[read_bytes] = '\0';
      	fprintf(stderr_file, "%s", result.stderr_);
      }
      fclose(stderr_file);
      // Cut string len to read size
    }
  } else {
    printf("Unable to fork\n");
  }
  // Delete input files. Clean my mess.
 }
 if (argp->part_ >= 0) {
       printf("Getting result from file\n");
 // Get required parts of stdout, stderr, status.
 static const size_t stream_len = 650;
 const size_t part = argp->part_;
 printf("Getting part: %lu from files\n", part);
 result.stdout_ = (char*) malloc(sizeof(char) * stream_len + 1); 
 result.stderr_ = (char*) malloc(sizeof(char) * stream_len + 1);
 
 			FILE* status_file = fopen("/tmp/status", "r");
      fscanf(status_file, "%d", &result.status_);
      fclose(status_file);
      
      FILE* stdout_file = fopen("/tmp/stdout", "r");
      fseek(stdout_file, part * stream_len, SEEK_SET);
      size_t len = fread(result.stdout_, sizeof(char), stream_len, stdout_file);
      result.stdout_[len] = '\0';
      fseek(stdout_file, 0L, SEEK_END);
      size_t out_size = ftell(stdout_file);
      fclose(stdout_file);
      
      FILE* stderr_file = fopen("/tmp/stderr", "r");
      fseek(stderr_file, part * stream_len, SEEK_SET);
      len = fread(result.stderr_, sizeof(char), stream_len, stderr_file);
      result.stderr_[len] = '\0';
      fseek(stderr_file, 0L, SEEK_END);
      size_t err_size = ftell(stderr_file);
      fclose(stderr_file);
      
      result.part_ = part;
      result.parts_ = (out_size > err_size) ? ceil(out_size / stream_len) 
                                            : ceil(err_size / stream_len);
  }
  return(&result);
}
